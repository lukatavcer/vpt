{"ArtisticToneMapper":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + 1.0) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_PI 3.1415926535897932384626\n\nuniform mediump sampler2D uTexture;\nuniform float uLow;\nuniform float uMid;\nuniform float uHigh;\nuniform float uSaturation;\n\nin vec2 vFragmentPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 color = texture(uTexture, vFragmentPosition);\n    color = (color - uLow) / (uHigh - uLow);\n    const vec3 gray = normalize(vec3(1));\n    color = vec4(mix(dot(color.rgb, gray) * gray, color.rgb, uSaturation), 1.0);\n    float midpoint = (uMid - uLow) / (uHigh - uLow);\n    float exponent = -log(2.0) / log(midpoint);\n    color = pow(color, vec4(exponent));\n    oColor = vec4(color.rgb, 1.0);\n}"},"ExposureToneMapper":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nconst float gamma = 2.2;\n\nvoid main() {\n    vec4 rgba = texture(uTexture, vFragmentPosition);\n    vec4 mapped = vec4(1.0) - exp(-rgb * uExposure);\n    mapped = pow(mapped, 1.0 / gamma);\n    color = vec4(mapped.rgb, 1.0);\n}"},"RangeToneMapper":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uMin;\nuniform float uMax;\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nvoid main() {\n    vec4 src = texture(uTexture, vFragmentPosition);\n    color = (src - uMin) / (uMax - uMin);\n}"},"ReinhardToneMapper":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\n@XYZITU2002\n\nvoid main() {\n    vec4 src = texture(uTexture, vFragmentPosition);\n    vec3 xyY = xyz2xyY(rgb2xyz(src.rgb));\n    xyY.z /= 1.0 / uExposure + xyY.z;\n    color = vec4(xyz2rgb(xyY2xyz(xyY)), 1.0);\n}"},"EAMGenerate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform float uStepSize;\nuniform float uOffset;\nuniform float uAlphaCorrection;  // Opacity\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nout vec4 oColor;\n\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    // Calculate where ray hits the bounding box and where it leaves it\n    // tbounds.x: in\n    // tbounds.y: out\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n\n    // Check if ray is out of bounds, return black color\n    if (tbounds.x >= tbounds.y) {\n        oColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        // Ray is inisde the volume, proceed with color accumulation\n        // Get from and to points on the ray\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n        float rayStepLength = distance(from, to) * uStepSize;\n\n        float t = 0.0;\n        vec3 pos;\n        float val;\n        vec4 colorSample;\n        vec4 accumulator = vec4(0.0);\n\n        // Sample through volume\n        // Check if\n        while (t < 1.0 && accumulator.a < 0.99) {\n            pos = mix(from, to, t);\n            // Get voxel value/intensity\n            val = texture(uVolume, pos).r;\n\n            // Map intensity from the transfer function\n            // Alpha-blending\n            colorSample = texture(uTransferFunction, vec2(val, 0.5));\n            colorSample.a *= rayStepLength * uAlphaCorrection;\n            colorSample.rgb *= colorSample.a;\n            accumulator += (1.0 - accumulator.a) * colorSample;\n            t += uStepSize;\n        }\n\n        if (accumulator.a > 1.0) {\n            accumulator.rgb /= accumulator.a;\n        }\n\n        oColor = vec4(accumulator.rgb, 1.0);\n    }\n}\n\n//"},"EAMIntegrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = texture(uFrame, vPosition);\n}\n\n//"},"EAMRender":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = texture(uAccumulator, vPosition);\n}\n\n//"},"EAMReset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\n}"},"ISOGenerate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n@unproject\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uClosest;\nuniform mediump sampler3D uVolume;\nuniform float uStepSize;\nuniform float uOffset;\nuniform float uIsovalue;\n\nin vec2 vPosition;\nin vec3 vRayFrom;\nin vec3 vRayTo;\n\nout vec4 oClosest;\n\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n    if (tbounds.x >= tbounds.y) {\n        oClosest = vec4(-1);\n    } else {\n        vec4 from = vec4(mix(vRayFrom, vRayTo, tbounds.x), tbounds.x);\n        vec4 to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\n\n        float closest = texture(uClosest, vPosition).w;\n        if (closest > 0.0) {\n            tbounds.y = closest;\n        }\n\n        float t = 0.0;\n        float offset = uOffset;\n        vec3 pos;\n        float value;\n        bool found = false;\n        do {\n            pos = mix(from.xyz, to.xyz, offset);\n            value = texture(uVolume, pos).r;\n            if (value >= uIsovalue) {\n                tbounds.y = mix(from.w, to.w, offset);\n                to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\n                found = true;\n            }\n            t += uStepSize;\n            offset = mod(offset + uStepSize + uOffset, 1.0);\n        } while (t < 1.0);\n\n        if (found) {\n            oClosest = to;\n        } else {\n            oClosest = vec4(-1);\n        }\n    }\n}\n\n//"},"ISOIntegrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\nout vec4 oClosest;\n\nvoid main() {\n    vec4 frame = texture(uFrame, vPosition);\n    vec4 acc = texture(uAccumulator, vPosition);\n    if (frame.w > 0.0 && acc.w > 0.0) {\n        oClosest = frame.w < acc.w ? frame : acc;\n    } else if (frame.w > 0.0) {\n        oClosest = frame;\n    } else {\n        oClosest = acc;\n    }\n}\n\n//"},"ISORender":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uClosest;\nuniform mediump sampler3D uVolume;\nuniform vec3 uLight;\nuniform vec3 uLightPosition;\nuniform vec3 uDiffuse;\n\nin vec2 vPosition;\n\nout vec4 oColor;\n\nvec3 gradient(vec3 pos, float h) {\n    vec3 positive = vec3(\n        texture(uVolume, pos + vec3( h, 0.0, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0,  h, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, 0.0,  h)).r\n    );\n    vec3 negative = vec3(\n        texture(uVolume, pos + vec3(-h, 0.0, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, -h, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, 0.0, -h)).r\n    );\n    return normalize(positive - negative);\n}\n\nvoid main() {\n    vec4 closest = texture(uClosest, vPosition);\n\n    if (closest.w > 0.0) {\n        vec3 normal = normalize(gradient(closest.xyz, 0.005));\n        vec3 light = normalize(uLight);\n        float lambert = max(dot(normal, light), 0.0);\n        oColor = vec4(uDiffuse * lambert, 1.0);\n    } else {\n        oColor = vec4(1.0);\n    }\n}\n\n//"},"ISOReset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oClosest;\n\nvoid main() {\n    oClosest = vec4(-1);\n}"},"MCCRender":{"compute":"#version 310 es\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n\n#define M_INVPI 0.31830988618\n#define M_2PI 6.28318530718\n#define EPS 1e-5\n\n@Photon\n\nlayout (std430, binding = 0) buffer bPhotons {\n    Photon sPhotons[];\n};\n\nlayout (rgba32f, binding = 0) restrict writeonly highp uniform image2D oRadiance;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform mediump sampler2D uEnvironment;\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\nuniform float uAbsorptionCoefficient;\nuniform float uScatteringCoefficient;\nuniform float uScatteringBias;\nuniform float uMajorant;\nuniform uint uMaxBounces;\nuniform uint uSteps;\n\n@rand\n@unprojectRand\n@intersectCube\n\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\n    vec3 from, to;\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    photon.bounces = 0u;\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n}\n\nvec4 sampleEnvironmentMap(vec3 d) {\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\n    return texture(uEnvironment, texCoord);\n}\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nvec3 randomDirection(vec2 U) {\n    float phi = U.x * M_2PI;\n    float z = U.y * 2.0 - 1.0;\n    float k = sqrt(1.0 - z * z);\n    return vec3(k * cos(phi), k * sin(phi), z);\n}\n\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\n    float g2 = g * g;\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\n    return (1.0 + g2 - c * c) / (2.0 * g);\n}\n\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\n    // generate random direction and adjust it so that the angle is HG-sampled\n    vec3 u = randomDirection(U);\n    if (abs(g) < EPS) {\n        return u;\n    }\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\n    float lambda = hgcos - dot(direction, u);\n    return normalize(u + lambda * direction);\n}\n\nvoid main() {\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\n    Photon photon = sPhotons[globalInvocationIndex];\n\n    vec2 r = rand(vec2(gl_GlobalInvocationID.xy) * uRandSeed);\n    for (uint i = 0u; i < uSteps; i++) {\n        r = rand(r);\n        float t = -log(r.x) / uMajorant;\n        photon.position += t * photon.direction;\n\n        vec4 volumeSample = sampleVolumeColor(photon.position);\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\n        float muScattering = volumeSample.a * uScatteringCoefficient;\n        float muNull = uMajorant - muAbsorption - muScattering;\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\n        float PNull = abs(muNull) / muMajorant;\n        float PAbsorption = muAbsorption / muMajorant;\n        float PScattering = muScattering / muMajorant;\n\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\n            // out of bounds\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\n            vec3 radiance = photon.transmittance * envSample.rgb;\n            photon.samples++;\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\n            imageStore(oRadiance, ivec2(gl_GlobalInvocationID.xy), vec4(photon.radiance, 1));\n            resetPhoton(r, photon);\n        } else if (photon.bounces >= uMaxBounces) {\n            // max bounces achieved -> only estimate transmittance\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\n            photon.transmittance *= 1.0 - weightAS;\n        } else if (r.y < PAbsorption) {\n            // absorption\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\n            photon.transmittance *= 1.0 - weightA;\n        } else if (r.y < PAbsorption + PScattering) {\n            // scattering\n            r = rand(r);\n            float weightS = muScattering / (uMajorant * PScattering);\n            photon.transmittance *= volumeSample.rgb * weightS;\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\n            photon.bounces++;\n        } else {\n            // null collision\n            float weightN = muNull / (uMajorant * PNull);\n            photon.transmittance *= weightN;\n        }\n    }\n\n    sPhotons[globalInvocationIndex] = photon;\n}\n\n//"},"MCCReset":{"compute":"#version 310 es\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\n@rand\n@unprojectRand\n@intersectCube\n\n@Photon\n\nlayout (std430, binding = 0) buffer bPhotons {\n    Photon sPhotons[];\n};\n\nvoid main() {\n    Photon photon;\n    vec3 from, to;\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\n    vec2 randState = rand(screen * uRandSeed);\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n    photon.radiance = vec3(1);\n    photon.bounces = 0u;\n    photon.samples = 0u;\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\n    sPhotons[globalInvocationIndex] = photon;\n}"},"MCMGenerate":{"vertex":"void main() {}\n\n//","fragment":"void main() {}\n\n//"},"MCMIntegrate":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_INVPI 0.31830988618\n#define M_2PI 6.28318530718\n#define EPS 1e-5\n\n@Photon\n\nuniform mediump sampler2D uPosition;\nuniform mediump sampler2D uDirection;\nuniform mediump sampler2D uTransmittance;\nuniform mediump sampler2D uRadiance;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform mediump sampler2D uEnvironment;\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\nuniform float uAbsorptionCoefficient;\nuniform float uScatteringCoefficient;\nuniform float uScatteringBias;\nuniform float uMajorant;\nuniform uint uMaxBounces;\nuniform uint uSteps;\n\nin vec2 vPosition;\n\nlayout (location = 0) out vec4 oPosition;\nlayout (location = 1) out vec4 oDirection;\nlayout (location = 2) out vec4 oTransmittance;\nlayout (location = 3) out vec4 oRadiance;\n\n@rand\n@unprojectRand\n@intersectCube\n\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\n    vec3 from, to;\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    photon.bounces = 0u;\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n}\n\nvec4 sampleEnvironmentMap(vec3 d) {\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\n    return texture(uEnvironment, texCoord);\n}\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nvec3 randomDirection(vec2 U) {\n    float phi = U.x * M_2PI;\n    float z = U.y * 2.0 - 1.0;\n    float k = sqrt(1.0 - z * z);\n    return vec3(k * cos(phi), k * sin(phi), z);\n}\n\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\n    float g2 = g * g;\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\n    return (1.0 + g2 - c * c) / (2.0 * g);\n}\n\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\n    // generate random direction and adjust it so that the angle is HG-sampled\n    vec3 u = randomDirection(U);\n    if (abs(g) < EPS) {\n        return u;\n    }\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\n    float lambda = hgcos - dot(direction, u);\n    return normalize(u + lambda * direction);\n}\n\nvoid main() {\n    Photon photon;\n    vec2 mappedPosition = vPosition * 0.5 + 0.5;\n    photon.position = texture(uPosition, mappedPosition).xyz;\n    vec4 directionAndBounces = texture(uDirection, mappedPosition);\n    photon.direction = directionAndBounces.xyz;\n    photon.bounces = uint(directionAndBounces.w + 0.5);\n    photon.transmittance = texture(uTransmittance, mappedPosition).rgb;\n    vec4 radianceAndSamples = texture(uRadiance, mappedPosition);\n    photon.radiance = radianceAndSamples.rgb;\n    photon.samples = uint(radianceAndSamples.w + 0.5);\n\n    vec2 r = rand(vPosition * uRandSeed);\n    for (uint i = 0u; i < uSteps; i++) {\n        r = rand(r);\n        float t = -log(r.x) / uMajorant;\n        photon.position += t * photon.direction;\n\n        vec4 volumeSample = sampleVolumeColor(photon.position);\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\n        float muScattering = volumeSample.a * uScatteringCoefficient;\n        float muNull = uMajorant - muAbsorption - muScattering;\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\n        float PNull = abs(muNull) / muMajorant;\n        float PAbsorption = muAbsorption / muMajorant;\n        float PScattering = muScattering / muMajorant;\n\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\n            // out of bounds\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\n            vec3 radiance = photon.transmittance * envSample.rgb;\n            photon.samples++;\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\n            resetPhoton(r, photon);\n        } else if (photon.bounces >= uMaxBounces) {\n            // max bounces achieved -> only estimate transmittance\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\n            photon.transmittance *= 1.0 - weightAS;\n        } else if (r.y < PAbsorption) {\n            // absorption\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\n            photon.transmittance *= 1.0 - weightA;\n        } else if (r.y < PAbsorption + PScattering) {\n            // scattering\n            r = rand(r);\n            float weightS = muScattering / (uMajorant * PScattering);\n            photon.transmittance *= volumeSample.rgb * weightS;\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\n            photon.bounces++;\n        } else {\n            // null collision\n            float weightN = muNull / (uMajorant * PNull);\n            photon.transmittance *= weightN;\n        }\n    }\n\n    oPosition = vec4(photon.position, 0);\n    oDirection = vec4(photon.direction, float(photon.bounces));\n    oTransmittance = vec4(photon.transmittance, 0);\n    oRadiance = vec4(photon.radiance, float(photon.samples));\n}\n\n//"},"MCMRender":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uColor;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(texture(uColor, vPosition).rgb, 1);\n}\n\n//"},"MCMReset":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\n@Photon\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\nin vec2 vPosition;\n\nlayout (location = 0) out vec4 oPosition;\nlayout (location = 1) out vec4 oDirection;\nlayout (location = 2) out vec4 oTransmittance;\nlayout (location = 3) out vec4 oRadiance;\n\n@rand\n@unprojectRand\n@intersectCube\n\nvoid main() {\n    Photon photon;\n    vec3 from, to;\n    vec2 randState = rand(vPosition * uRandSeed);\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n    photon.radiance = vec3(1);\n    photon.bounces = 0u;\n    photon.samples = 0u;\n    oPosition = vec4(photon.position, 0);\n    oDirection = vec4(photon.direction, float(photon.bounces));\n    oTransmittance = vec4(photon.transmittance, 0);\n    oRadiance = vec4(photon.radiance, float(photon.samples));\n}"},"MCSGenerate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\nout vec2 vPosition;\n\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_INVPI 0.31830988618\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform mediump sampler2D uEnvironment;\nuniform float uOffset;\nuniform float uSigmaMax;\nuniform float uAlphaCorrection;\nuniform vec3 uScatteringDirection;\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nin vec2 vPosition;\nout vec4 oColor;\n\n@intersectCube\n\nvec2 rand(vec2 p) {\n    const mat2 M = mat2(\n        23.14069263277926, 2.665144142690225,\n        12.98987893203892, 78.23376739376591);\n    const vec2 D = vec2(\n        12345.6789,\n        43758.5453);\n    vec2 dotted = M * p;\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\n    return fract(mapped * D);\n}\n\nvec4 sampleEnvironmentMap(vec3 d) {\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\n    return texture(uEnvironment, texCoord);\n}\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nfloat sampleDistance(vec3 from, vec3 to, inout vec2 seed) {\n    float maxDistance = distance(from, to);\n    float dist = 0.0;\n    float invSigmaMax = 1.0 / uSigmaMax;\n    float invMaxDistance = 1.0 / maxDistance;\n\n    do {\n        seed = rand(seed);\n        dist -= log(1.0 - seed.x) * invSigmaMax;\n        if (dist > maxDistance) {\n            break;\n        }\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\n        float alphaSample = transferSample.a * uAlphaCorrection;\n        if (seed.y < alphaSample * invSigmaMax) {\n            break;\n        }\n    } while (true);\n\n    return dist;\n}\n\nfloat sampleTransmittance(vec3 from, vec3 to, inout vec2 seed) {\n    float maxDistance = distance(from, to);\n    float dist = 0.0;\n    float invSigmaMax = 1.0 / uSigmaMax;\n    float invMaxDistance = 1.0 / maxDistance;\n    float transmittance = 1.0;\n\n    do {\n        seed = rand(seed);\n        dist -= log(1.0 - seed.x) * invSigmaMax;\n        if (dist > maxDistance) {\n            break;\n        }\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\n        float alphaSample = transferSample.a * uAlphaCorrection;\n        transmittance *= 1.0 - alphaSample * invSigmaMax;\n    } while (true);\n\n    return transmittance;\n}\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec3 rayDirectionUnit = normalize(rayDirection);\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n\n    if (tbounds.x >= tbounds.y) {\n        oColor = sampleEnvironmentMap(rayDirectionUnit);\n    } else {\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n        float maxDistance = distance(from, to);\n\n        vec2 seed = vPosition + rand(vec2(uOffset, uOffset));\n        float dist = sampleDistance(from, to, seed);\n\n        if (dist > maxDistance) {\n            oColor = sampleEnvironmentMap(rayDirectionUnit);\n        } else {\n            from = mix(from, to, dist / maxDistance);\n            tbounds = max(intersectCube(from, uScatteringDirection), 0.0);\n            to = from + uScatteringDirection * tbounds.y;\n            vec4 diffuseColor = sampleVolumeColor(from);\n            vec4 lightColor = sampleEnvironmentMap(uScatteringDirection);\n            float transmittance = sampleTransmittance(from, to, seed);\n\n            oColor = diffuseColor * lightColor * transmittance;\n        }\n    }\n}\n\n//"},"MCSIntegrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\nuniform float uInvFrameNumber;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 acc = texture(uAccumulator, vPosition);\n    vec4 frame = texture(uFrame, vPosition);\n    oColor = acc + (frame - acc) * uInvFrameNumber;\n}\n\n//"},"MCSRender":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 acc = texture(uAccumulator, vPosition);\n    oColor = acc;\n}\n\n//"},"MCSReset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\n}"},"MIPGenerate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform float uStepSize;\nuniform float uOffset;\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nout float oColor;\n\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n    if (tbounds.x >= tbounds.y) {\n        oColor = 0.0;\n    } else {\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n\n        float t = 0.0;\n        float val = 0.0;\n        float offset = uOffset;\n        vec3 pos;\n        do {\n            pos = mix(from, to, offset);\n            val = max(texture(uVolume, pos).r, val);\n            t += uStepSize;\n            offset = mod(offset + uStepSize, 1.0);\n        } while (t < 1.0);\n        oColor = val;\n    }\n}\n\n//"},"MIPIntegrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\nout float oColor;\n\nvoid main() {\n    float acc = texture(uAccumulator, vPosition).r;\n    float frame = texture(uFrame, vPosition).r;\n    oColor = max(acc, frame);\n}\n\n//"},"MIPRender":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    float acc = texture(uAccumulator, vPosition).r;\n    oColor = vec4(acc, acc, acc, 1.0);\n}\n\n//"},"MIPReset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout float oColor;\n\nvoid main() {\n    oColor = 0.0;\n}"},"RCGenerate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform float uStepSize;\nuniform float uOffset;\nuniform float uAlphaCorrection;  // Opacity\nuniform bool uRandomize;\nuniform float uReflectionModel;\nuniform vec3 uLight;  // Position or direction\nuniform float uLightType;\nuniform vec3 uLightColor;\nuniform float uLightAttenuation;\nuniform float uLightIntensity;\n\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nout vec4 oColor;\n\n\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    // Calculate where ray hits the bounding box and where it leaves it\n    // tbounds.x: in\n    // tbounds.y: out\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n\n    // Check if ray is out of bounds, return black color\n    if (tbounds.x >= tbounds.y) {\n        oColor = vec4(0.0, 0.0, 0.0, 1.0);  // black background\n        //        oColor = vec4(1.0, 1.0, 1.0, 1.0);  // white background\n    } else {\n        // Ray is inisde the volume, proceed with color accumulation\n        // Get from and to points on the ray\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n        float rayStepLength = distance(from, to) * uStepSize;\n\n        float t = 0.0;\n        vec3 pos;\n        vec4 voxel;\n        float val;\n        vec3 gradient;\n        float gradMagnitude;\n        vec4 colorSample;\n        vec4 accumulator = vec4(0.0);\n        vec3 light = uLight;\n\n        // Phong parameters\n        vec3 specColor = vec3(1.0, 1.0, 1.0);\n\n        // Random sampling offset\n        float offset = uOffset;\n\n        // Sample through volume\n        // Check if\n        float diffMultiplier = 32.0;\n        // Ambient Lighting\n        if (uLightType == 0.0) {\n            diffMultiplier /= 4.0;\n\n            while (t < 1.0 && accumulator.a < 0.99) {\n                // Random offset\n                if (uRandomize == true) {\n                    pos = mix(from, to, offset);\n                } else {\n                    pos = mix(from, to, t);\n                }\n\n                // Get voxel value/intensity\n                voxel = texture(uVolume, pos);\n                val = voxel.r;\n                gradient = voxel.gba;\n\n                gradient -= 0.5;\n                gradient *= 2.0;\n                gradMagnitude = length(gradient);\n\n                // Map intensity & color from the transfer function\n                colorSample = texture(uTransferFunction, vec2(val, gradMagnitude));\n                colorSample.a *= rayStepLength * uAlphaCorrection * gradMagnitude * diffMultiplier;\n\n                colorSample.rgb *= colorSample.a;\n                colorSample.rgb = mix(colorSample.rgb, uLightColor, colorSample.a);\n\n                accumulator += (1.0 - accumulator.a) * colorSample;\n                offset = mod(offset + uStepSize, 1.0);\n                t += uStepSize;\n            }\n        } else if (uLightType == 1.0) {\n            // Directed Light\n            light = normalize(light);\n\n            while (t < 1.0 && accumulator.a < 0.99) {\n                // Random offset\n                if (uRandomize == true) {\n                    pos = mix(from, to, offset);\n\n                } else {\n                    pos = mix(from, to, t);\n                }\n\n                // Get voxel value/intensity\n                voxel = texture(uVolume, pos);\n                val = voxel.r;\n                gradient = voxel.gba;\n\n                gradient -= 0.5;\n                gradient *= 2.0;\n                gradMagnitude = length(gradient);\n                vec3 normal = normalize(gradient);\n                float lambert = max(dot(normal, light), 0.15);\n\n                // Map intensity & color from the transfer function\n                colorSample = texture(uTransferFunction, vec2(val, gradMagnitude));\n\n                // Mix light color (diffuse) with the material (transfer function) color\n//                colorSample.rgb = mix(colorSample.rgb, uLightColor, colorSample.a);\n                 colorSample.rgb += uLightColor;\n                 colorSample.rgb *= lambert;\n\n                if (uReflectionModel == 1.0) {\n                    // Phong\n                    vec3 reflectDir = reflect(-light, normal);\n                    vec3 viewDir = normalize(-pos);\n                    float specular = 0.0;\n\n                    if (lambert > 0.0) {\n                        float specAngle = max(dot(reflectDir, viewDir), 0.0);\n                        specular = pow(specAngle, 4.0);\n                    }\n\n                    // vec4(ambientColor + lambert* diffuseColor + specular*specColor, 1.0);\n                    // Hardcoded spec color & intensity, make it whiter\n                    colorSample.rgb += specular*(mix(colorSample.rgb, vec3(0.8), 0.5)) * 0.9;\n                }\n                // Increase alpha on parts that are more shaded (make them less transparent)\n                if (lambert > 0.5) {\n                    colorSample.a *=  1.5;\n                }\n                colorSample.a *= rayStepLength * uAlphaCorrection * gradMagnitude * diffMultiplier;\n                colorSample.rgb *= colorSample.a;\n\n                accumulator += (1.0 - accumulator.a) * colorSample;\n                offset = mod(offset + uStepSize, 1.0);\n                t += uStepSize;\n            }\n        } else if (uLightType == 2.0) {\n            // Point Light\n            vec3 lightDirection;\n            light = normalize(light);\n\n            while (t < 1.0 && accumulator.a < 0.99) {\n                // Random offset\n                if (uRandomize == true) {\n                    pos = mix(from, to, offset);\n\n                } else {\n                    pos = mix(from, to, t);\n                }\n\n                lightDirection = light - pos;\n                // Get voxel value/intensity\n                voxel = texture(uVolume, pos);\n                val = voxel.r;\n                gradient = voxel.gba;\n\n                gradient -= 0.5;\n                gradient *= 2.0;\n                gradMagnitude = length(gradient);\n                vec3 normal = normalize(gradient);\n                float lambert = max(dot(normal, normalize(lightDirection)), 0.15);\n\n                // Map intensity & color from the transfer function\n                float koef = 1.0 - (exp(-0.5 * gradMagnitude));\n                colorSample = texture(uTransferFunction, vec2(val, gradMagnitude));\n\n                // Mix light color with the material (transfer function) color\n//                colorSample.rgb = mix(colorSample.rgb, uLightColor, colorSample.a);\n                colorSample.rgb += uLightColor;\n                colorSample.rgb *= lambert;\n                if (uReflectionModel == 1.0) {\n                    // Phong\n                    vec3 reflectDir = reflect(-light, normal);\n                    vec3 viewDir = normalize(-pos);\n                    float specular = 0.0;\n\n                    if (lambert > 0.0) {\n                        float specAngle = max(dot(reflectDir, viewDir), 0.0);\n                        specular = pow(specAngle, 4.0);\n                    }\n\n                    // vec4(ambientColor + lambert* diffuseColor + specular*specColor, 1.0);\n                    // Hardcoded spec color & intensity\n//                    colorSample.rgb += specular*(colorSample.rgb+vec3(0.2)) * 0.9;\n                    colorSample.rgb += specular*(mix(colorSample.rgb, vec3(0.5), 0.2)) * 0.9;\n                }\n\n                // Increase alpha on parts that are more shaded (make them less transparent)\n                if (lambert > 0.5) {\n                    colorSample.a *=  1.5;\n                }\n                colorSample.a *= rayStepLength * uAlphaCorrection * gradMagnitude * diffMultiplier;\n                colorSample.rgb *= colorSample.a;\n\n                float d = length(lightDirection);\n\n                // Smooth attenuation\n                // float attenuation = 1.0 / ((1.0 - uLightIntensity) + 1.0*d + uLightAttenuation*d*d);\n                float attenuation = 1.0 / (0.2 + (1.0 - uLightIntensity)*d + uLightAttenuation*d*d);\n\n                colorSample.rgb *= attenuation;\n\n                accumulator += (1.0 - accumulator.a) * colorSample;\n                offset = mod(offset + uStepSize, 1.0);\n                t += uStepSize;\n            }\n        }\n\n        if (accumulator.a > 1.0) {\n            accumulator.rgb /= accumulator.a;\n        }\n\n        oColor = vec4(accumulator.rgb, 1.0); // black bounding box\n        //        oColor = vec4(vec3(1.0) - accumulator.rgb, 1.0); // white bounding box\n        //        gl_FragColor = oColor;\n        // Debug light color\n//        if (uReflectionModel == 0.0) {\n//            oColor = vec4(0.0, 0.0, 1.0, 1.0);\n//        } else if (uReflectionModel == 1.0) {\n//            oColor = vec4(1.0, 1.0, 1.0, 1.0);\n//        }\n    }\n}\n\n//"},"RCIntegrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\nuniform float uInvFrameNumber;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n//    oColor = texture(uFrame, vPosition);\n    vec4 acc = texture(uAccumulator, vPosition);\n    vec4 frame = texture(uFrame, vPosition);\n    oColor = acc + (frame - acc) * uInvFrameNumber;\n}\n\n//"},"RCRender":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = texture(uAccumulator, vPosition);\n}\n\n//"},"RCReset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\n}"},"average":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTextureAccumulator;\nuniform mediump sampler2D uTextureNew;\nuniform float uInvn; // inverse number of samples\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nvoid main() {\n    vec4 a = texture(uTextureAccumulator, vFragmentPosition);\n    vec4 b = texture(uTextureNew, vFragmentPosition);\n    color = a + (b - a) * uInvn;\n}"},"drawTransferFunction":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform vec2 uPosition;\nuniform vec2 uSize;\nuniform vec4 uColor;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    float r = length((uPosition - vPosition) / uSize);\n    oColor = uColor * exp(-r * r);\n}"},"quad":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nvoid main() {\n    color = texture(uTexture, vFragmentPosition);\n}"},"test":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n\n//","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 color;\n\nvoid main() {\n    color = vec4(1.0, 0.5, 0.2, 1.0);\n}"}}